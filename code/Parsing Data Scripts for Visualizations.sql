#Custom SQL Query1:
#Parsing the Sentiment_map:

SELECT 
  USER_ID, 
  AVERAGE_STARS,
  COMPLIMENT_COOL,
  COMPLIMENT_CUTE,
  COMPLIMENT_FUNNY,
  COMPLIMENT_HOT,
  COMPLIMENT_LIST,
  COMPLIMENT_MORE,
  COMPLIMENT_NOTE, 
  COMPLIMENT_PHOTOS,
  COMPLIMENT_PLAIN,
  COMPLIMENT_PROFILE,
  COMPLIMENT_WRITER,
  COOL,
  ELITE,
  FANS,
  FUNNY,
  NAME,
  REVIEW_COUNT,
  USEFUL,
  YELPING_SINCE ,
  FIRST_SEEN ,
  LAST_SEEN ,
  DATE_DIFF,
  DIFFERENT_BUSINESS_COUNT,
  AVG_RATING,
  MIN_STARS ,
  MAX_STARS ,
  CATEGORY_MAP,
  FRIENDS_COUNT,

  IFF(SENTIMENT_MAP:positive IS NULL, 0, SENTIMENT_MAP:positive::INT) AS positive_sentiment,
  IFF(SENTIMENT_MAP:negative IS NULL, 0, SENTIMENT_MAP:negative::INT) AS negative_sentiment,
  IFF(SENTIMENT_MAP:neutral IS NULL, 0, SENTIMENT_MAP:neutral::INT) AS neutral_sentiment
FROM 
  "DATA_228_PROJECT"."YELP"."USERS",
  LATERAL FLATTEN(input => SENTIMENT_MAP)

#Custom SQL Query2:
#Parsing Category_Map Field:

SELECT 
  USER_ID, 
  CATEGORY.key AS Category_Name,
  CATEGORY.value::INTEGER AS Category_Count
FROM 
  "DATA_228_PROJECT"."YELP"."USERS",
  LATERAL FLATTEN(input => CATEGORY_MAP) AS CATEGORY

#Custom SQL Query 3:
#Parse Elite Column:

SELECT 
  USER_ID,
  VALUE::INTEGER AS ELITE_YEAR
FROM 
    "DATA_228_PROJECT"."YELP"."USERS",
  LATERAL FLATTEN(input => SPLIT(ELITE, ',')) AS t
